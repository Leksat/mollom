<?php

use Drupal\comment\CommentInterface;
use Drupal\Component\Utility\Unicode;
use Drupal\Core\Url;
use \Drupal\mollom\Controller\FormController;
use Drupal\mollom\Entity\Form;
use Drupal\mollom\Entity\FormInterface;
use Drupal\mollom\Utility\Mollom;
use Drupal\node\Entity\NodeType;

/**
 * Implements hook_permission().
 */
function mollom_permission() {
  return array(
    'administer mollom' => array(
      'title' => t('Administer Mollom-protected forms and Mollom settings'),
    ),
    'bypass mollom protection' => array(
      'title' => t('Bypass Mollom protection on forms'),
    ),
    'access mollom statistics' => array(
      'title' => t('View Mollom statistics'),
    ),
    'report to mollom' => array(
      'title' => t('Report content as inappropriate'),
    )
  );
}

/**
 * Implements hook_mollom_form_list().
 */
function comment_mollom_form_list() {
  $forms = array();
  foreach (\Drupal\node\Entity\NodeType::loadMultiple() as $type) {
    $form_id = "comment_node_{$type->type}_form";
    $forms[$form_id] = array(
      'title' => t('@name comment form', array('@name' => $type->name)),
      'entity' => 'comment',
      'bundle' => 'comment_node_' . $type->type,
      'delete form' => 'comment_confirm_delete',
      //'delete form file' => array(
      //  'name' => 'comment.admin',
      //),
      'report access' => array('administer comments'),
      'entity delete multiple callback' => 'comment_delete_multiple',
      'entity report access callback' => 'comment_mollom_entity_report_access',
    );
  }
  return $forms;
}

/**
 * Implements hook_mollom_form_info().
 */
function comment_mollom_form_info($form_id) {
  $form_info = array(
    'mode' => FormInterface::MOLLOM_MODE_ANALYSIS,
    'bypass access' => array('administer comments'),
    'moderation callback' => 'comment_mollom_form_moderation',
    'elements' => array(
      'subject' => t('Subject'),
      'comment_body' => t('Body'),
    ),
    'mapping' => array(
      'post_title' => 'subject',
      'author_name' => 'name',
      'author_mail' => 'mail',
      'author_url' => 'homepage',
    ),
  );
  // Retrieve internal type from $form_id.
  $comment_bundle = Unicode::substr($form_id, 0, -5);
  FormController::mollom_form_info_add_fields($form_info, 'comment', $comment_bundle);
  return $form_info;
}

/**
 * Implements hook_mollom_form_info().
 */
function node_mollom_form_info($form_id) {
  // Retrieve internal type from $form_id.
  $entity_type = Unicode::substr($form_id, 0, -10);

  if (!$type = NodeType::load($entity_type)) {
    return '';
  }
  $form_info = array(
    // @todo This is incompatible with node access.
    'bypass access' => array('bypass node access'),
    'bundle' => $type->type,
    'moderation callback' => 'node_mollom_form_moderation',
    'elements' => array(),
    'mapping' => array(
      'author_name' => 'name',
    ),
  );
  // @see node_permission()
  //if (in_array($type->type, node_permissions_get_configured_types())) {
  //  $form_info['bypass access'][] = 'edit any ' . $type->type . ' content';
  //  $form_info['bypass access'][] = 'delete any ' . $type->type . ' content';
  //}
  // @see node_content_form()
  //if ($type->has_title) {
  //  $form_info['elements']['title'] = check_plain($type->title_label);
  //  $form_info['mapping']['post_title'] = 'title';
  //}
  FormController::mollom_form_info_add_fields($form_info, 'node', $type->type);
  return $form_info;
}


/**
 * Implements hook_mollom_form_list().
 */
function node_mollom_form_list() {
  $forms = array();
  /** @var NodeType[] $types */
  $types = NodeType::loadMultiple();
  foreach ($types as $type) {
    $form_id = $type->type . '_node_form';
    $forms[$form_id] = array(
      'title' => t('@name form', array('@name' => $type->label())),
      'entity' => 'node',
      'bundle' => $type->type,
      'delete form' => 'node_delete_confirm',
      'delete form file' => array(
        'name' => 'node.pages',
      ),
      'report access' => array('bypass node access', 'administer nodes'),
      'entity report access callback' => 'node_mollom_entity_report_access',
    );
  }
  return $forms;
}


/**
 * Entity report access callback for comments.
 *
 * @param $entity
 *   Optional entity object to check access to a specific entity.
 */
function comment_mollom_entity_report_access(CommentInterface $entity = NULL) {
  // All comments can be reported as long as the user has access to view the
  // node and it's comments.
  if (!\Drupal::currentUser()->hasPermission('access comments')) {
    return FALSE;
  }
  if (!empty($entity)) {
    return $entity->getCommentedEntity()->access('view');
  }
  return TRUE;
}

/**
 * Implements hook_mollom_form_list().
 */
function contact_mollom_form_list() {
  $forms['feedback_contact_message_form'] = array(
    'title' => t('Site-wide contact form'),
  );
  $forms['feedback_contact_personal_form'] = array(
    'title' => t('User contact form'),
  );
  return $forms;
}

/**
 * Implements hook_mollom_form_info().
 */
function contact_mollom_form_info($form_id) {
  switch ($form_id) {
    case 'feedback_contact_message_form':
      $form_info = array(
        'mode' => FormInterface::MOLLOM_MODE_ANALYSIS,
        'bypass access' => array('administer contact forms'),
        'mail ids' => array('contact_page_mail'),
        'elements' => array(
          'subject' => t('Subject'),
          'message' => t('Message'),
        ),
        'mapping' => array(
          'post_title' => 'subject',
          'author_name' => 'name',
          'author_mail' => 'mail',
        ),
      );
      return $form_info;

    case 'feedback_contact_personal_form':
      $form_info = array(
        'mode' => FormInterface::MOLLOM_MODE_ANALYSIS,
        'bypass access' => array('administer users'),
        'mail ids' => array('contact_user_mail'),
        'elements' => array(
          'subject' => t('Subject'),
          'message' => t('Message'),
        ),
        'mapping' => array(
          'post_title' => 'subject',
          'author_name' => 'name',
          'author_mail' => 'mail',
        ),
      );
      return $form_info;
  }
}

/**
 * Implements hook_mollom_form_info().
 */
function user_mollom_form_info($form_id) {
  switch ($form_id) {
    case 'user_register_form':
    case 'user_profile_form':
      $form_info = array(
        'bypass access' => array('administer users'),
        'moderation callback' => 'user_mollom_form_moderation',
        'mail ids' => array('user_register_pending_approval_admin'),
        'mapping' => array(
          'author_name' => 'name',
          'author_mail' => 'mail',
        ),
      );
      FormController::mollom_form_info_add_fields($form_info, 'user', 'user');
      return $form_info;

    case 'user_pass':
      $form_info = array(
        'bypass access' => array('administer users'),
        'mapping' => array(
          'post_id' => 'uid',
          'author_name' => 'name',
          // The 'name' form element accepts either a username or mail address.
          'author_mail' => 'name',
        ),
      );
      return $form_info;
  }
}

/**
 * Implements hook_mollom_form_list().
 */
function user_mollom_form_list() {
  $forms['user_register_form'] = array(
    'mode' => FormInterface::MOLLOM_MODE_CAPTCHA,
    'title' => t('User registration form'),
    'type' => 'user',
    'entity' => 'user',
    'bundle' => 'user',
    'delete form' => 'user_cancel_confirm_form',
    'report path' => 'user/%id/cancel',
    'report access' => array('administer users'),
  );
  $forms['user_profile_form'] = $forms['user_register_form'];
  $forms['user_profile_form']['title'] = t('User profile form');

  $forms['user_pass'] = array(
    'mode' => FormInterface::MOLLOM_MODE_CAPTCHA,
    'title' => t('User password request form'),
  );
  return $forms;
}

/**
 * Implements hook_mollom_form_info_alter().
 *
 * Adds profile fields exposed on the user registration form.
 */
function profile_mollom_form_info_alter(&$form_info, $form_id) {
  if ($form_id != 'user_register_form') {
    return;
  }
  // @see profile_form_profile()
  $result = db_query("SELECT name, title FROM {profile_field} WHERE register = 1 AND type IN (:types)", array(
    ':types' => array('textfield', 'textarea', 'url', 'list'),
  ));
  foreach ($result as $field) {
    $form_info['elements'][$field->name] = check_plain($field->title);
  }
}

/**
 * Mollom form moderation callback for comments.
 */
function comment_mollom_form_moderation(&$form, \Drupal\Core\Form\FormState $form_state) {
  $form_state->setValue('status', CommentInterface::NOT_PUBLISHED);
}

/**
 * Implements hook_form_alter().
 *
 * Protects all configured forms with Mollom.
 *
 * @see mollom_element_info()
 * @see mollom_process_mollom()
 * @see mollom_pre_render_mollom()
 */
function mollom_form_alter(&$form, \Drupal\Core\Form\FormState $form_state, $form_id) {
  // Skip installation and update forms.
  if (defined('MAINTENANCE_MODE')) {
    return;
  }
  // Retrieve a list of all protected forms once.
  $forms = \Drupal\mollom\Controller\FormController::mollom_form_cache();
  // Remind of enabled testing mode on all protected forms.
  if ($form_id == 'comment_comment_form') {
    /** @var \Drupal\comment\Entity\Comment $comment */
    $comment = $form_state->getFormObject()->getEntity();
    $form_id = 'comment_' . $comment->getCommentedEntity()->getEntityTypeId() . '_' . $comment->getCommentedEntity()->bundle() . '_form';
  }

  $url = Url::fromRoute('<current>');
  $current_path = $url->toString();
  if (isset($forms['protected'][$form_id]) || strpos($current_path, 'admin/config/content/mollom') === 0) {
    Mollom::displayMollomTestModeWarning();
  }

  $current_user = \Drupal::currentUser();

  // Site administrators don't have their content checked with Mollom.
  // @todo: Enable this when Development has completed
  if (!$current_user->hasPermission('bypass mollom protection')) {
    // Retrieve configuration for this form.
    if (isset($forms['protected'][$form_id])) {
      /** @var \Drupal\mollom\Entity\Form $mollom_form */
      $mollom_form_id = $forms['protected'][$form_id];
      $mollom_form = \Drupal\mollom\Entity\Form::load($mollom_form_id);

      // Determine whether to bypass validation for the current user.
      //foreach ($mollom_form['bypass access'] as $permission) {
      //  if ($current_user->hasPermission($permission)) {
      //    return;
      //  }
      //}
      // Verify global Mollom configuration status.
      // Only do this if the form is actually protected and if the current user
      // is not privileged to bypass the Mollom protection. Otherwise, if e.g.
      // the Testing API is down, then every hook_form_alter() for every single
      // form on the page would potentially cause a (two) API keys verification
      // requests (in case caches are disabled).
      // If API keys have been configured, then the form has to be processed,
      // regardless of whether API keys could be verified; otherwise, the
      // fallback mode would not be triggered.
      $status = Mollom::getAPIKeyStatus();
      if (!$status['isConfigured']) {
        return;
      }

      // Add Mollom form widget.
      $form['mollom'] = array(
        '#type' => 'mollom',
        '#mollom_form' => $mollom_form,
        // #type 'actions' defaults to 100.
        '#weight' => (isset($form['actions']['#weight']) ? $form['actions']['#weight'] - 1 : 99),
        '#tree' => TRUE,
      );

      // Add Mollom form validation handlers.
      // Form-level validation handlers are required, since we need access to
      // all validated and submitted form values. _form_validate() invokes
      // #element_validate handlers while it is recursing into the form.

      $form['#validate'][] = array('\Drupal\mollom\Controller\FormController', 'mollom_validate_captcha');
      $form['#validate'][] = array('\Drupal\mollom\Controller\FormController', 'mollom_validate_analysis');
      $form['#validate'][] = array('\Drupal\mollom\Controller\FormController', 'mollom_validate_post');

      // Append a submit handler to store Mollom session data. Requires that
      // the primary submit handler has run already, so a potential 'post_id'
      // mapping can be retrieved from $form_state['values'].
      // @todo Core: node_form_submit() uses a button-level submit handler,
      //   which invokes form-level submit handlers before the node/entity is
      //   saved, so $form_state does not contain the new node ID yet. There is
      //   no #post_submit property or form processing phase, we could rely on.
      //   Potentially applies to other contrib entities, too.
      // @see http://drupal.org/node/1150756

      if (isset($form_state->getBuildInfo()['base_form_id']) && $form_state->getBuildInfo()['base_form_id'] == 'node_form') {
        $form_submit_key = &$form['actions']['submit'];
      }
      else {
        $form_submit_key = &$form;
      }
      $form_submit_key['#submit'][] = array('\Drupal\mollom\Controller\FormController', 'mollom_form_submit');

      // Add link to privacy policy on forms protected via textual analysis,
      // if enabled.
      if ($mollom_form->mode == Form::MOLLOM_MODE_ANALYSIS && \Drupal::config('mollom.settings')->get('privacy_link', 1)) {
        $form['mollom']['privacy'] = array(
          '#prefix' => '<div class="description mollom-privacy">',
          '#suffix' => '</div>',
          '#markup' => t('By submitting this form, you accept the <a href="@privacy-policy-url" class="mollom-target" rel="nofollow">Mollom privacy policy</a>.', array(
            '@privacy-policy-url' => 'https://mollom.com/web-service-privacy-policy',
          )),
          '#weight' => 10,
        );
      }
    }
  }
  // Integrate with delete confirmation forms to send feedback to Mollom.
  /*
  if (isset($forms['delete'][$form_id])) {
    // Check whether the user is allowed to report to Mollom. Limiting report
    // access is optional for forms integrating via 'delete form' and allowed by
    // default, since we assume that users being able to delete entities are
    // sufficiently trusted to also report to Mollom.
    $access = TRUE;
    // Retrieve information about the protected form; the form cache maps delete
    // confirmation forms to protected form_ids, and protected form_ids to their
    // originating modules.
    $mollom_form_id = $forms['delete'][$form_id];
    $module = $forms['protected'][$mollom_form_id];
    $form_info = mollom_form_load($mollom_form_id, $module);

    // For entities, there is only one delete confirmation form per entity type.
    // But not all of its bundles may be protected. We therefore need to figure
    // out whether the bundle of the entity being deleted is protected - which
    // is a reverse-mapping that does not exist in D7.
    $is_protected = TRUE;
    $is_entity = !empty($form_info['entity']);
    $has_entity_argument = isset($form_state['build_info']['args'][0]) && is_object($form_state['build_info']['args'][0]);
    if ($is_entity && $has_entity_argument) {
      list(, , $bundle) = entity_extract_ids($form_info['entity'], $form_state['build_info']['args'][0]);
      $is_protected = db_query_range('SELECT 1 FROM {mollom_form} WHERE entity = :entity AND bundle = :bundle', 0, 1, array(
        ':entity' => $form_info['entity'],
        ':bundle' => $bundle,
      ))->fetchField();
    }
    if (!$is_protected) {
      return;
    }
    // Check access, if there is a 'report access' permission list.
    if (isset($form_info['report access'])) {
      $access = FALSE;
      foreach ($form_info['report access'] as $permission) {
        if (user_access($permission)) {
          $access = TRUE;
          break;
        }
      }
    }
    /*if ($access) {
      mollom_data_delete_form_alter($form, $form_state);
      // Report before deleting. This needs to be handled here, since
      // mollom_data_delete_form_alter() is re-used for mass-operation forms.
      array_unshift($form['#submit'], 'mollom_data_delete_form_submit');
    }
  }*/
}
